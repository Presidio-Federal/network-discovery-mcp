name: "HAI Network Discovery"

on:
  workflow_dispatch:
    inputs:
      seed_host:
        description: "Seed device IP or hostname"
        required: true
        default: "192.168.100.1"
      username:
        description: "Device username"
        required: true
        default: "cisco"
      password:
        description: "Device password (use GitHub secrets for production)"
        required: false
        default: "cisco"
      ports:
        description: "Ports to scan (comma-separated)"
        required: false
        default: "22,443"
      poll_interval:
        description: "Polling interval in seconds"
        required: false
        default: "10"

env:
  BASE_URL: "https://localhost:8000"
  POLL_INTERVAL: ${{ github.event.inputs.poll_interval || '10' }}
  CURL_OPTS: "-k"  # -k flag to ignore SSL certificate validation

jobs:
  discover-network:
    runs-on: ubuntu-latest
    outputs:
      job_id: ${{ steps.seed.outputs.job_id }}
      reachable_hosts: ${{ steps.scan.outputs.reachable_hosts }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
      
      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl
      
      # Download required docker-compose files
      - name: Download docker-compose files
        run: |
          echo "Downloading docker-compose files..."
          curl -o docker-compose.yml https://raw.githubusercontent.com/Presidio-Federal/network-discovery-mcp/main/docker-compose.yml
          curl -o docker-compose.mcp.yml https://raw.githubusercontent.com/Presidio-Federal/network-discovery-mcp/main/docker-compose.mcp.yml
          echo "Docker compose files downloaded successfully"
      
      # Step 0 - Deploy environment
      - name: Deploy network discovery environment
        run: |
          echo "Starting network discovery services..."
          # Check if docker-compose file exists
          if [ ! -f "./docker-compose.yml" ]; then
            echo "ERROR: docker-compose.yml not found!"
            ls -la
            exit 1
          fi
          
          # Start the containers
          docker compose -f ./docker-compose.yml up -d
          
          # Check if containers started
          echo "Checking if containers started..."
          if ! docker ps | grep -q "network-discovery"; then
            echo "ERROR: Containers failed to start!"
            docker ps
            docker compose logs
            exit 1
          fi
          
          # Wait for service to start
          echo "Waiting for service to start..."
          MAX_RETRIES=30
          RETRY_COUNT=0
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            RESPONSE=$(curl ${{ env.CURL_OPTS }} -s -w "\n%{http_code}" ${{ env.BASE_URL }}/docs)
            HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
            
            if [ "$HTTP_CODE" == "200" ]; then
              echo "Service is up and running"
              break
            fi
            
            echo "Waiting for service to start (attempt $((RETRY_COUNT+1))/$MAX_RETRIES)..."
            echo "HTTP Code: $HTTP_CODE"
            
            if [ $RETRY_COUNT -eq 10 ] || [ $RETRY_COUNT -eq 20 ]; then
              echo "Checking container status..."
              docker ps
              docker compose logs --tail 20
            fi
            
            sleep 2
            RETRY_COUNT=$((RETRY_COUNT+1))
          done
          
          if [ $RETRY_COUNT -eq $MAX_RETRIES ]; then
            echo "ERROR: Service failed to start within the timeout period"
            docker ps
            docker compose logs
            docker compose down
            exit 1
          fi
          
          # Show API endpoints
          echo "Available API endpoints:"
          curl ${{ env.CURL_OPTS }} -s ${{ env.BASE_URL }}/docs | grep -o '/v1/[^"]*' || echo "No endpoints found or docs not available"
      
      # Step 1 - Start Seeding
      - name: Start seeding process
        id: seed
        run: |
          echo "Starting seed process from ${{ github.event.inputs.seed_host }}..."
          
          # Get password from input or secret
          PASSWORD="${{ github.event.inputs.password }}"
          if [ -z "$PASSWORD" ]; then
            PASSWORD="${{ secrets.DEVICE_PASSWORD }}"
          fi
          
          # Check if API is responding
          echo "Checking if API is responding..."
          API_RESPONSE=$(curl ${{ env.CURL_OPTS }} -s -w "\n%{http_code}" "${{ env.BASE_URL }}/docs")
          HTTP_CODE=$(echo "$API_RESPONSE" | tail -n1)
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "ERROR: API is not responding correctly. HTTP code: $HTTP_CODE"
            echo "API response: $(echo "$API_RESPONSE" | head -n -1)"
            echo "Checking container status..."
            docker ps
            docker compose logs
            exit 1
          fi
          
          # Start seeder
          echo "Sending seed request..."
          SEED_RESPONSE=$(curl ${{ env.CURL_OPTS }} -s -w "\n%{http_code}" -X POST "${{ env.BASE_URL }}/v1/seed" \
            -H "Content-Type: application/json" \
            -d "{
              \"seed_host\": \"${{ github.event.inputs.seed_host }}\",
              \"credentials\": {
                \"username\": \"${{ github.event.inputs.username }}\",
                \"password\": \"$PASSWORD\"
              },
              \"methods\": [\"interfaces\",\"routing\",\"arp\",\"cdp\"]
            }")
          
          HTTP_CODE=$(echo "$SEED_RESPONSE" | tail -n1)
          SEED_BODY=$(echo "$SEED_RESPONSE" | head -n -1)
          
          if [ "$HTTP_CODE" != "200" ]; then
            echo "ERROR: Seed request failed. HTTP code: $HTTP_CODE"
            echo "Response body: $SEED_BODY"
            docker compose logs
            exit 1
          fi
          
          # Parse job_id from response
          echo "Parsing job_id from response..."
          echo "Response: $SEED_BODY"
          
          JOB_ID=$(echo "$SEED_BODY" | jq -r '.job_id')
          
          if [ -z "$JOB_ID" ] || [ "$JOB_ID" == "null" ]; then
            echo "ERROR: Failed to parse job_id from response"
            echo "Response body: $SEED_BODY"
            docker compose logs
            exit 1
          fi
          
          echo "Job ID: $JOB_ID"
          echo "job_id=$JOB_ID" >> $GITHUB_OUTPUT
          
          # Poll for seeder completion
          echo "Waiting for seeder to complete..."
          until [[ "$(curl ${{ env.CURL_OPTS }} -s ${{ env.BASE_URL }}/v1/status/$JOB_ID | jq -r '.seeder.status')" == "completed" ]]; do
            echo "Seeder in progress..."
            sleep ${{ env.POLL_INTERVAL }}
          done
          echo "Seeder completed"
      
      # Step 2 - Run IP Scan
      - name: Run IP scan
        id: scan
        run: |
          JOB_ID="${{ steps.seed.outputs.job_id }}"
          
          # Process probe ports
          IFS=',' read -ra PORT_ARRAY <<< "${{ github.event.inputs.ports }}"
          PROBE_PORTS="["
          for port in "${PORT_ARRAY[@]}"; do
            if [ "$PROBE_PORTS" != "[" ]; then
              PROBE_PORTS="$PROBE_PORTS,"
            fi
            PROBE_PORTS="$PROBE_PORTS$port"
          done
          PROBE_PORTS="$PROBE_PORTS]"
          
          echo "Running IP scan with ports $PROBE_PORTS..."
          curl ${{ env.CURL_OPTS }} -s -X POST "${{ env.BASE_URL }}/v1/scan" \
            -H "Content-Type: application/json" \
            -d "{
              \"job_id\": \"$JOB_ID\",
              \"ports\": $PROBE_PORTS,
              \"concurrency\": 200
            }"
          
          # Poll for scanner completion
          echo "Waiting for scanner to complete..."
          until [[ "$(curl ${{ env.CURL_OPTS }} -s ${{ env.BASE_URL }}/v1/status/$JOB_ID | jq -r '.scanner.status')" == "completed" ]]; do
            echo "Scanner in progress..."
            sleep ${{ env.POLL_INTERVAL }}
          done
          echo "Scanner completed"
          
          # Create artifacts directory
          mkdir -p ./discovery-artifacts
          
          # Retrieve reachable hosts
          echo "Retrieving reachable hosts..."
          curl ${{ env.CURL_OPTS }} -s "${{ env.BASE_URL }}/v1/scan/$JOB_ID/reachable" | jq '.' > ./discovery-artifacts/reachable.json
          REACHABLE=$(jq -c '.hosts' ./discovery-artifacts/reachable.json)
          echo "reachable_hosts=$REACHABLE" >> $GITHUB_OUTPUT
          
          # Display summary
          echo "Scan results:"
          echo "Reachable hosts: $(jq '.hosts | length' ./discovery-artifacts/reachable.json)"
          
      # Step 3 - Fingerprint
      - name: Fingerprint devices
        id: fingerprint
        run: |
          JOB_ID="${{ steps.seed.outputs.job_id }}"
          
          echo "Starting fingerprinting..."
          curl ${{ env.CURL_OPTS }} -s -X POST "${{ env.BASE_URL }}/v1/fingerprint" \
            -H "Content-Type: application/json" \
            -d "{\"job_id\": \"$JOB_ID\"}"
          
          # Poll for fingerprinting completion
          echo "Waiting for fingerprinting to complete..."
          until [[ "$(curl ${{ env.CURL_OPTS }} -s ${{ env.BASE_URL }}/v1/status/$JOB_ID | jq -r '.fingerprinter.status')" == "completed" ]]; do
            echo "Fingerprinting in progress..."
            sleep ${{ env.POLL_INTERVAL }}
          done
          echo "Fingerprinting completed"
          
          # Save fingerprint results
          curl ${{ env.CURL_OPTS }} -s "${{ env.BASE_URL }}/v1/fingerprint/$JOB_ID" | jq '.' > ./discovery-artifacts/fingerprints.json
      
      # Step 4 - Collect Device State
      - name: Collect device configurations
        id: state
        run: |
          JOB_ID="${{ steps.seed.outputs.job_id }}"
          
          # Get password from input or secret
          PASSWORD="${{ github.event.inputs.password }}"
          if [ -z "$PASSWORD" ]; then
            PASSWORD="${{ secrets.DEVICE_PASSWORD }}"
          fi
          
          echo "Collecting device configurations..."
          curl ${{ env.CURL_OPTS }} -s -X POST "${{ env.BASE_URL }}/v1/state/collect" \
            -H "Content-Type: application/json" \
            -d "{
              \"job_id\": \"$JOB_ID\",
              \"credentials\": {
                \"username\": \"${{ github.event.inputs.username }}\",
                \"password\": \"$PASSWORD\"
              },
              \"concurrency\": 25
            }"
          
          # Poll for state collection completion
          echo "Waiting for state collection to complete..."
          until [[ "$(curl ${{ env.CURL_OPTS }} -s ${{ env.BASE_URL }}/v1/status/$JOB_ID | jq -r '.state_collector.status')" == "completed" ]]; do
            echo "State collection in progress..."
            sleep ${{ env.POLL_INTERVAL }}
          done
          echo "State collection completed"
      
      # Step 5 - Build and Load Batfish Snapshot
      - name: Process with Batfish
        id: batfish
        run: |
          JOB_ID="${{ steps.seed.outputs.job_id }}"
          
          echo "Building Batfish snapshot..."
          curl ${{ env.CURL_OPTS }} -s -X POST "${{ env.BASE_URL }}/v1/batfish/build" \
            -H "Content-Type: application/json" \
            -d "{\"job_id\": \"$JOB_ID\"}"
          
          echo "Loading Batfish snapshot..."
          curl ${{ env.CURL_OPTS }} -s -X POST "${{ env.BASE_URL }}/v1/batfish/load" \
            -H "Content-Type: application/json" \
            -d "{\"job_id\": \"$JOB_ID\"}"
          
          # Poll for Batfish loading completion
          echo "Waiting for Batfish snapshot loading to complete..."
          until [[ "$(curl ${{ env.CURL_OPTS }} -s ${{ env.BASE_URL }}/v1/status/$JOB_ID | jq -r '.batfish_loader.status')" == "loaded" ]]; do
            echo "Batfish loading in progress..."
            sleep ${{ env.POLL_INTERVAL }}
          done
          echo "Batfish snapshot loaded"
          
          # Step 6 - Retrieve Topology
          echo "Retrieving network topology..."
          curl ${{ env.CURL_OPTS }} -s "${{ env.BASE_URL }}/v1/batfish/topology?job_id=$JOB_ID" -o ./discovery-artifacts/topology.json
          curl ${{ env.CURL_OPTS }} -s "${{ env.BASE_URL }}/v1/batfish/topology/html?job_id=$JOB_ID" -o ./discovery-artifacts/topology.html
          
          echo "Network topology saved to discovery-artifacts/topology.json and discovery-artifacts/topology.html"
      
      # Step 7 - Upload Artifacts
      - name: Upload discovery artifacts
        uses: actions/upload-artifact@v4
        with:
          name: network-discovery-results
          path: |
            ./discovery-artifacts/reachable.json
            ./discovery-artifacts/fingerprints.json
            ./discovery-artifacts/topology.json
            ./discovery-artifacts/topology.html
          retention-days: 7
      
      # Cleanup
      - name: Cleanup
        if: always()
        run: |
          echo "Cleaning up containers..."
          # Use the downloaded docker-compose file for cleanup
          if [ -f "./docker-compose.yml" ]; then
            docker compose -f ./docker-compose.yml down
          else
            docker compose down
          fi
          
          # Fix permissions on artifacts directory to avoid EACCES errors in future runs
          echo "Fixing permissions on artifacts directory..."
          if [ -d "./artifacts" ]; then
            # Force remove problematic hidden directories first
            sudo find ./artifacts -type d -name ".*" -exec rm -rf {} + 2>/dev/null || true
            
            # Fix permissions on all files and directories
            sudo chown -R $(id -u):$(id -g) ./artifacts
            sudo chmod -R 755 ./artifacts
            
            # If permissions can't be fixed, try to remove the entire directory
            sudo rm -rf ./artifacts || true
          fi
          
          # Clean up docker volumes that might have permission issues
          echo "Cleaning up docker volumes..."
          docker volume prune -f
          
          echo "Cleanup complete"